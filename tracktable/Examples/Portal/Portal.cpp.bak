//
// Portal.cpp
//
// C++ routines for portal manipulation
//
//
// Created by Danny Rintoul
// Copyright (c) 2014 Sandia Corporation.  All rights reserved.
//

#include <algorithm>
#include <iterator>
#include <boost/bind/bind.hpp>
#include <boost/shared_ptr.hpp>
#include "Portal.h"

unsigned int my_pow(unsigned int base, unsigned int power);

void SubDividePortal(PP &parent, unsigned int interval_x, unsigned int interval_y)
{

  std::vector<PP> temp_vec;

  point_ll orig_ll = parent->ll;
  double orig_x = orig_ll.get<0>();
  double orig_y = orig_ll.get<1>();

  point_ll delta = parent->ur;
  boost::geometry::subtract_point(delta,parent->ll);
  double delta_x = delta.get<0>()/static_cast<double>(interval_x);
  double delta_y = delta.get<1>()/static_cast<double>(interval_y);

  unsigned int cur_level = parent->level+1;
  for (unsigned int i = 0; i < interval_x; ++i)
    for (unsigned int j = 0; j < interval_y; ++j) {
      PP p(new Portal);
      p->level = parent->level+1;
      p->ll = point_ll(orig_x + i*delta_x,orig_y + j*delta_y);
      p->ur = point_ll(orig_x + (i+1)*delta_x,orig_y + (j+1)*delta_y);
      temp_vec.push_back(p);
    }

  // Now, go through all of the flights associated with the parent portal
  // and assign them to the child portals.  This is ridiculously 
  // inefficient.  This is where all of the time is taken.

  unsigned int x_bin, y_bin;
  for (fp_itr itr = parent->flights.begin(); itr != parent->flights.end(); ++itr)
    for (std::vector<PP>::iterator itr2 = temp_vec.begin(); itr2 != temp_vec.end(); ++itr2) {
      boost::geometry::model::box<point_ll> temp_box((*itr2)->ll,(*itr2)->ur);
      if (boost::geometry::intersects(**itr,temp_box))
        (*itr2)->flights.insert(*itr);
    }
/*    for (Flight::iterator itr2 = (*itr)->begin(); 
     itr2 != (*itr)->end(); ++itr2) {
      x_bin = get_bin(orig_x,itr2->get_longitude(),delta_x);
      y_bin = get_bin(orig_y,itr2->get_latitude(),delta_y);
      if ((x_bin >= 0) && (x_bin < interval_x) && 
       (y_bin >= 0) && (y_bin < interval_y)) {
        temp_vec[x_bin*interval_y + y_bin]->flights.insert(*itr);
      }
    } */

  // Now that we've created the children, assign them to the parent as
  // long as there are flights in them.

  std::remove_copy_if(temp_vec.begin(),temp_vec.end(),
   std::inserter(parent->children,parent->children.end()),
   boost::bind(&std::set<Flight*>::empty,boost::bind(&Portal::flights,_1)));

  return;
}

int RefinePairs(my_pq<Portal_pair> &pairs, const unsigned int depth, const unsigned int interval_x, const unsigned int interval_y)
{
  if ((pairs.top().p1->level < depth) || (pairs.top().p2->level < depth)) {
    RefineTopPair(pairs,depth,interval_x,interval_y);
    return 1;
  } else
    return 0;
}

void RefineTopPair(my_pq<Portal_pair> &pairs, 
 const unsigned int depth, const unsigned int interval_x, const unsigned int interval_y)
{

  // Decompose the first portal by default (it's the largest), or 
  // do the second if the first is already small enough

//  Portal *shrink, *keep;
  PP shrink, keep;
  if (pairs.top().p1->level < depth) {
    shrink = pairs.top().p1;
    keep = pairs.top().p2;
  } else {
    shrink = pairs.top().p2;
    keep = pairs.top().p1;
  }
  pairs.pop();

  // If we haven't already created the children in the decomposition, do so

  if (shrink->children.empty())
    SubDividePortal(shrink,interval_x,interval_y);

  // Now reassign the pairs

  for (pp_itr itr = shrink->children.begin(); itr 
   != shrink->children.end(); ++itr) {
    if (PortalDist(*itr,keep) < 10.0)
      continue;
    MakeNewPair(pairs,*itr,keep);
  }
}

void MakeNewPair(my_pq<Portal_pair> &pairs, PP &p1, PP &p2)
{
  Portal_pair pp;
  if (p1->flights.size() > p2->flights.size()) {
    pp.p1 = p1;
    pp.p2 = p2;
  } else {
    pp.p1 = p2;
    pp.p2 = p1;
  }

  UpdatePairVal(pp);
  if (pp.val > 0)
    pairs.push(pp);

  return;
}

void RemoveTopPair(my_pq<Portal_pair> &pairs, PP &US)
{
  
  std::vector<Flight*> to_remove;
  std::set_intersection(pairs.top().p1->flights.begin(),
                        pairs.top().p1->flights.end(),
                        pairs.top().p2->flights.begin(),
                        pairs.top().p2->flights.end(),
                        std::back_inserter(to_remove));

  pairs.pop();  // Finally remove the top one

  DescendantRemoveFlights(US,to_remove);

  // Now that the flights are removed, we have to go through and redo the
  // Portal_pairs.  We need to recalculate their overlap and re-heap them.

  std::for_each(pairs.impl().begin(),pairs.impl().end(),UpdatePairVal);
  pairs.impl().erase(std::remove_if(pairs.impl().begin(),pairs.impl().end(),
   boost::bind(std::equal_to<unsigned int>(),
   boost::bind(&Portal_pair::val,_1),0U)),pairs.impl().end());
  pairs.make_heap();

  return;
}

void RemoveTopPortal(my_pq<PP,std::vector<PP>,PPCompare> &portals, PP &US)
{
  std::vector<Flight*> to_remove(portals.top()->flights.begin(),
   portals.top()->flights.end());
  portals.pop();
  DescendantRemoveFlights(US,to_remove);
  portals.make_heap();

  return;
}
void DescendantRemoveFlights(PP &portal,std::vector<Flight*> &to_remove)
{
  
  fp_itr itr1 = portal->flights.begin();
  std::vector<Flight*>::iterator itr2 = to_remove.begin();
  while (itr1 != portal->flights.end() && itr2 != to_remove.end()) {
    if (*itr1 < *itr2) ++itr1;
    else if (*itr2 < *itr1) ++itr2;
    else {portal->flights.erase(itr1++);}
  }

  for (pp_itr itr = portal->children.begin(); 
   itr != portal->children.end(); ++itr)
    DescendantRemoveFlights(*itr,to_remove);

  return;
}

void UpdatePairVal(Portal_pair &pp)
{
  pp.val = 0;
  fp_itr itr1 = pp.p1->flights.begin();
  fp_itr itr2 = pp.p2->flights.begin();
  while (itr1 != pp.p1->flights.end() && itr2 != pp.p2->flights.end()) {
    if (*itr1 < *itr2) ++itr1;
    else if (*itr2 < *itr1) ++itr2;
    else {++pp.val; ++itr1; ++itr2;}
  }

  return;
}

int RefineSingles(my_pq<PP,std::vector<PP>,PPCompare> &portals, const unsigned int depth, const unsigned int interval_x, const unsigned int interval_y)
{
  if (portals.top()->level < depth) {
    RefineTopSingle(portals,depth,interval_x,interval_y);
    return 1;
  } else
    return 0;
}

void RefineTopSingle(my_pq<PP,std::vector<PP>,PPCompare> &portals, 
 const unsigned int depth, const unsigned int interval_x, 
 const unsigned int interval_y)
{
  PP shrink = portals.top();
  portals.pop();

  SubDividePortal(shrink,interval_x,interval_y);
  for (pp_itr itr = shrink->children.begin(); 
   itr != shrink->children.end(); ++itr)
    portals.push(*itr);
}
  
std::ostream& operator<< (std::ostream &out, Portal &p)
{
  out << "Level :" << p.level << std::endl;
  out << "(" << p.ll.get<0>() << "," << p.ll.get<1>() << ") -> ";
  out << "(" << p.ur.get<0>() << "," << p.ur.get<1>() << ")" << std::endl;
  out << "flights.size() = " << p.flights.size() << std::endl;
  out << "children.size() = " << p.children.size();

  return out;
}

double PortalDist(const PP &p1, const PP &p2)
{
  // Ugly, but we can assume they don't overlap

  double x_dist, y_dist;

  x_dist = std::max(std::max(abs(p1->ll.get<0>()-p2->ll.get<0>()),
                             abs(p1->ur.get<0>()-p2->ur.get<0>())),
                    std::max(abs(p1->ll.get<0>()-p2->ur.get<0>()),
                             abs(p1->ur.get<0>()-p2->ll.get<0>())));

  y_dist = std::max(std::max(abs(p1->ll.get<1>()-p2->ll.get<1>()),
                             abs(p1->ur.get<1>()-p2->ur.get<1>())),
                    std::max(abs(p1->ll.get<1>()-p2->ur.get<1>()),
                             abs(p1->ur.get<1>()-p2->ll.get<1>())));

  return hypot(x_dist,y_dist);
}

int get_bin(const double start, const double val, const double width)
{
  return static_cast<int>(floor((val-start)/width));
}

unsigned int my_pow(unsigned int base, unsigned int power)
{
  unsigned int res = 1;

  for (unsigned int i = 0; i < power; ++i)
    res *= base;

  return res;
}
